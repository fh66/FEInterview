###  1. obj = { num1: 111 }; obj.child = obj = { num2: 222 }; console.log(obj.child);输出什么？为什么？

输出undefined

在JavaScript中，当你连续进行赋值操作时，这些操作是从右到左执行的。因此，当你写下 `obj.child = obj = { num2: 222 };` 时，实际执行的顺序如下：

1. `obj = { num2: 222 }`：首先，`obj` 被赋予一个新的对象 `{ num2: 222 }`。
2. `obj.child = obj`：然后，这个新对象（现在是 `obj` 的值）的 `child` 属性被赋值为 `obj` 自身。

但这里有一个微妙的地方需要注意。当第一步执行时，`obj` 已经不再指向原来的 `{ num1: 111 }` 对象，而是指向了新的 `{ num2: 222 }` 对象。因此，当第二步执行时，你实际上是在给 `{ num2: 222 }` 这个新对象添加 `child` 属性，并将其设置为自身。

所以，当你最后尝试访问 `obj.child` 时，你实际上是在访问 `{ num2: 222 }.child`，而不是原始的 `{ num1: 111 }` 对象。由于新对象 `{ num2: 222 }` 并没有 `child` 属性，因此结果为 `undefined`。

换句话说，这段代码的效果是创建了一个新对象 `{ num2: 222 }` 并尝试将其 `child` 属性设置为其自身，但由于这个属性在设置之前并不存在，所以最终 `obj.child` 是 `undefined`。