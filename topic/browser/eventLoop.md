### 宏任务是什么？ 微任务是什么？

在 JavaScript 的异步编程中，宏任务（MacroTasks）和微任务（MicroTasks）是任务执行队列的两个主要概念，它们决定了代码的执行顺序。

### 宏任务 (MacroTasks)

宏任务是由宿主环境（通常是浏览器或 Node.js）引起的任务，它们包括但不限于：

- `setTimeout`
- `setInterval`
- `setImmediate`（Node.js 环境）
- `requestAnimationFrame`（浏览器环境）
- I/O 操作
- UI 渲染（浏览器环境）

当宏任务执行完毕后，在下一个宏任务执行之前，会执行所有的微任务。

### 微任务 (MicroTasks)

微任务通常是由语言本身引起的，比如由 JavaScript 引擎内部产生的任务，它们包括：

- `Promise.then` 和 `Promise.catch` 的回调函数
- `async/await`（它们是基于 Promise 的）
- `MutationObserver` 的回调函数
- `queueMicrotask` 方法（在现代浏览器中提供的显式微任务队列操作）

微任务的特点是它们在当前宏任务结束后立即执行，在进行下一个宏任务之前，会清空微任务队列。这意味着微任务的优先级高于宏任务。

### 执行顺序

在事件循环的每一轮中，都会按照以下顺序执行：

1. 执行一个宏任务（从宏任务队列中取出）
2. 执行所有微任务（直到微任务队列清空）：
   - 执行过程中可能会产生新的微任务，这些新的微任务也会在当前轮次执行。
3. 如果有必要，进行 UI 渲染。
4. 开始下一轮事件循环，执行下一个宏任务。

### 为什么需要宏任务和微任务？

这种区分允许 JavaScript 引擎优化性能和响应能力。微任务提供了一种方式来处理异步操作，使得它们尽可能快地执行，而不必等待下一轮事件循环。这对于需要快速响应的操作，比如界面更新或者处理 Promise 链非常有用。而宏任务则通常用于较为耗时的操作，如 I/O 或定时操作。

### 为何区分宏任务和微任务？

这种区分宏任务和微任务的主要原因是为了提高效率和响应性。通过微任务，JavaScript 引擎可以快速地处理在当前宏任务执行期间产生的异步事件，而不必等待下一个事件循环的迭代。这意味着微任务非常适合用于处理高优先级的小任务，如动态调整布局、响应用户输入等。

由于微任务在宏任务之间执行，这使得它们的响应更快，延迟更低。例如，当您在 JavaScript 中使用 `Promise` 或 `async/await` 时，任何 `then()` 或 `await` 后面的代码都将作为微任务被排队，等待当前执行栈

清空后立即执行。

这种机制也确保了 JavaScript 的非阻塞特性和对异步编程的支持。例如，假设您有一个宏任务，如 `setTimeout`，它设置了一个回调函数在未来某个时间点执行。在它等待执行的同时，您的代码可能会产生多个 `Promise`。这些 `Promise` 的回调（微任务）会在宏任务之间尽快执行，不必等到 `setTimeout` 的回调执行，从而有效地利用了 CPU 周期，并且在感知上为用户提供了更连贯、更平滑的体验。

### 事件循环和任务队列

整个机制是由 JavaScript 的事件循环和任务队列支持的。事件循环是 JavaScript 运行时的核心概念，负责接收任务，执行任务和进入下一个循环。任务队列分为宏任务队列和微任务队列，分别存放不同类型的任务。在每个宏任务执行后，引擎会处理所有微任务，然后可能会进行浏览器的重绘，之后再执行下一个宏任务。

```javascript
console.log(1);
setTimeout(() => {
  console.log(2);
}, 0);

const p = new Promise((resolve, reject) => {
  console.log(3);
  resolve("success"); // 标记为成功
  console.log(4);
});

p.then((value) => {
  console.log(value);
});

console.log(5);
```

上面的代码执行顺序是什么？ 具体解释一下

上述代码中包含了同步代码、宏任务（`setTimeout`），以及微任务（`Promise.then`）。它们的执行顺序如下：

1. 同步代码 `console.log(1);` 执行，打印 `1`。
2. `setTimeout` 是宏任务，它的回调函数被放入宏任务队列，计划在未来的某个时刻执行（尽管延迟是 `0`，但它不会立即执行）。
3. 同步代码继续执行，`console.log(3);` 打印 `3`。
4. `Promise` 构造函数中的代码是同步执行的，因此 `resolve("success");` 会立即执行，将这个 Promise 标记为已解决（fulfilled）。
5. 在 `Promise` 构造函数内部继

续执行，`console.log(4);` 打印 `4`。 6. 同步代码 `console.log(5);` 执行，打印 `5`。

1. 同步代码执行完毕后，JavaScript 运行时开始处理微任务队列，在当前宏任务结束之前，微任务队列中所有的任务都会被执行。`p.then(...)` 里的回调是一个微任务，它将 `console.log(value);` 打印出解决（fulfilled）状态的 Promise 结果 `"success"`。
2. 当当前宏任务（包括它的微任务）全部完成后，事件循环会取出下一个宏任务来执行。这里，`setTimeout(..., 0)` 的回调函数被调用，打印 `2`。

所以，整个输出的顺序是 `1 3 4 5 success 2`。